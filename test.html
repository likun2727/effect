<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Liquid Cloud Particle Flow</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle, #a0caff 0%, #ffb3b3 50%, #fff7b0 100%);
    }

    #bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
</head>

<body>
  <div id="bg"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, particleSystem;
    const particleCount = 8000;
    let geometry, material;
    let bgPhase = 0;
    let particleSquat = 0;
    let bgSquat = 0;
    let isBursting = false;
    let bgBurst = 0; // 0~1，0正常，1=最强变化
    let innerMix = bgBurst;
    let midMix = bgBurst * 0.5;
    let outMix = bgBurst * 0.2;
    let burstStartTime = 0;
    const burstDuration = 1.2; // 秒
    init();
    animate();


    // 监听键盘
    window.addEventListener('keydown', function (e) {
      // 空格键
      if (e.code === 'Space' && !isBursting) {
        triggerBurst()
      }
    });
    window.addEventListener('keydown', function (e) {
      if (e.code === 'Space' && !isBursting) {
        isBursting = true;
        burstStartTime = performance.now() * 0.001;
        bgBurst = 1.0;
      }
      if (e.key === 's' || e.key === 'S') {
        bgSquat = 1.0;
        particleSquat = 1.0;  // 粒子下沉启动
      }
    });

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 180;

      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        let r = Math.random() * 80;
        let theta = Math.random() * 2 * Math.PI;
        let phi = Math.acos(2 * Math.random() - 1);

        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        sizes[i] = 2.0 + Math.random() * 2.0;

        // 蓝色粒子
        colors[i * 3] = 0.3 + Math.random() * 0.1;
        colors[i * 3 + 1] = 0.5 + Math.random() * 0.1;
        colors[i * 3 + 2] = 1.0;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));

      const vertexShader = `
        attribute float size;
        attribute vec3 aColor;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          vColor = aColor;
          float dist = length(position);
          vAlpha = 1.0 - smoothstep(0.0, 520.0, dist);
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          float d = distance(gl_PointCoord, vec2(0.5));
          float alpha = 1.0 - smoothstep(0.0, 0.5, d);
          gl_FragColor = vec4(vColor, alpha * vAlpha);
        }
      `;

      material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });

      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setClearColor(0x000000, 0); // 透明背景
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function triggerBurst() {
      if (!isBursting) {
        isBursting = true;
        burstStartTime = performance.now() * 0.001;
        bgBurst = 1.0;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = geometry.attributes.position.array;
      const time = performance.now() * 0.001;

      // 用爆发因子
      let burstFactor = 1.0;
      if (isBursting) {
        const elapsed = time - burstStartTime;
        if (elapsed < burstDuration) {
          burstFactor = 1.0 + 2.5 * Math.max(0, 1 - elapsed / burstDuration);
        } else {
          isBursting = false;
        }
      }

      for (let i = 0; i < particleCount; i++) {
        let idx = i * 3;
        let x = positions[idx];
        let y = positions[idx + 1];
        let z = positions[idx + 2];
        let dist = Math.sqrt(x * x + y * y + z * z);
        let speed = (0.03 + dist * 0.002) * burstFactor;
        let dir = new THREE.Vector3(x, y, z).normalize();
        positions[idx] += dir.x * speed;
        positions[idx + 1] += dir.y * speed;
        positions[idx + 2] += dir.z * speed;
        if (dist > 600) {
          let r = 1 + Math.random() * 2;
          let theta = Math.random() * 2 * Math.PI;
          let phi = Math.acos(2 * Math.random() - 1);
          positions[idx] = r * Math.sin(phi) * Math.cos(theta);
          positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[idx + 2] = r * Math.cos(phi);
        }
      }

      geometry.attributes.position.needsUpdate = true;
      particleSystem.rotation.y += 0.0002;
      updateBackground();
      renderer.render(scene, camera);
    }


    function lerpColor(c1, c2, t) {
      return [
        Math.round(c1[0] * (1 - t) + c2[0] * t),
        Math.round(c1[1] * (1 - t) + c2[1] * t),
        Math.round(c1[2] * (1 - t) + c2[2] * t)
      ];
    }

    function updateBackground() {
      bgPhase += 0.01;

      // 逐渐回落
      if (bgBurst > 0) {
        bgBurst -= 0.003; // 恢复慢一些
        if (bgBurst < 0) bgBurst = 0;
      }
      if (bgSquat > 0) {
        bgSquat -= 0.003; // 可以再慢点
        if (bgSquat < 0) bgSquat = 0;
      }

      // 预设主色
      const centerBase = [160, 210, 255];
      const ring1Base = [160, 210, 255];
      const ring2Base = [255, 179, 179];
      const ring3Base = [255, 247, 176];

      // 空格爆发用
      const burstColor = [255, 255, 255];

      // 下蹲特效色：底部发光蓝紫，外圈冷色，中心更暗
      const squatCenter = [90, 80, 255];    // 中心强烈蓝紫
      const squatRing1 = [70, 120, 220];    // 靠近中心的深蓝
      const squatRing2 = [30, 70, 150];     // 更远的深蓝青
      const squatRing3 = [25, 40, 80];      // 最外圈近乎夜色

      // ——中心色融合比例——
      // 两特效可以同时叠加（极少出现，优先爆发色）
      let mixBurst = bgBurst;
      let mixSquat = bgSquat * (1 - mixBurst); // 同时爆发时优先爆发

      // 普通模式
      let center = lerpColor(centerBase, burstColor, mixBurst);
      center = lerpColor(center, squatCenter, mixSquat);

      let ring1 = lerpColor(ring1Base, burstColor, mixBurst * 0.7);
      ring1 = lerpColor(ring1, squatRing1, mixSquat * 0.7);

      let ring2 = lerpColor(ring2Base, burstColor, mixBurst * 0.4);
      ring2 = lerpColor(ring2, squatRing2, mixSquat * 0.4);

      let ring3 = lerpColor(ring3Base, burstColor, mixBurst * 0.18);
      ring3 = lerpColor(ring3, squatRing3, mixSquat * 0.15);

      // 渐变中心，普通模式在中间，下蹲时往下偏移
      let baseY = 50 + Math.cos(bgPhase * 0.5) * 5;
      let squatY = 90; // 渐变中心移动到屏幕下方
      let centerY = baseY * (1 - mixSquat) + squatY * mixSquat;
      let centerX = 50 + Math.sin(bgPhase * 0.7) * 5; // 水平方向可略偏

      document.body.style.background =
        `radial-gradient(circle at ${centerX}% ${centerY}%, 
      rgb(${center.join(',')}) 0%,
      rgb(${ring1.join(',')}) 15%,
      rgb(${ring2.join(',')}) 50%,
      rgb(${ring3.join(',')}) 100%
    )`;
    }


  </script>
</body>

</html>