<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Liquid Cloud Particle Flow</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle, #a0caff 0%, #ffb3b3 50%, #fff7b0 100%);
    }

    #bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
</head>

<body>
  <div id="bg"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, particleSystem;
    const particleCount = 8000;
    let geometry, material;
    let bgPhase = 0;
    let particleSquat = 0;
    let bgSquat = 0;
    let isBursting = false;
    let bgBurst = 0;
    let innerMix = bgBurst;
    let midMix = bgBurst * 0.5;
    let outMix = bgBurst * 0.2;
    let burstStartTime = 0;
    const burstDuration = 1.0;
    
    // 修改：记录每个粒子的运动模式和创建时间
    let particleStates = new Array(particleCount).fill().map(() => ({
      mode: 'normal', // 'normal' 或 'falling'
      createdAt: 0
    }));
    
    init();
    animate();

    // 监听键盘
    window.addEventListener('keydown', function (e) {
      // 空格键
      if (e.code === 'Space' && !isBursting) {
        triggerBurst()
      }
      if (e.key === 's' || e.key === 'S') {
        bgSquat = 1.0;
        particleSquat = 1.0;
        // 修改：将当前所有粒子标记为下落模式，但不改变它们的位置
        const currentTime = performance.now() * 0.001;
        for (let i = 0; i < particleCount; i++) {
          particleStates[i].mode = 'falling';
          particleStates[i].createdAt = currentTime;
        }
      }
    });

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 180;

      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        // 修改：所有粒子都从中心球形区域生成
        let r = Math.random() * 80;
        let theta = Math.random() * 2 * Math.PI;
        let phi = Math.acos(2 * Math.random() - 1);
        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        sizes[i] = 2.0 + Math.random() * 2.0;

        // 蓝色粒子
        colors[i * 3] = 0.3 + Math.random() * 0.1;
        colors[i * 3 + 1] = 0.5 + Math.random() * 0.1;
        colors[i * 3 + 2] = 1.0;
        
        // 初始化粒子状态
        particleStates[i] = {
          mode: 'normal',
          createdAt: 0
        };
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));

      const vertexShader = `
        attribute float size;
        attribute vec3 aColor;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          vColor = aColor;
          float dist = length(position);
          vAlpha = 1.0 - smoothstep(0.0, 520.0, dist);
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          float d = distance(gl_PointCoord, vec2(0.5));
          float alpha = 1.0 - smoothstep(0.0, 0.5, d);
          gl_FragColor = vec4(vColor, alpha * vAlpha);
        }
      `;

      material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });

      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function triggerBurst() {
      if (!isBursting) {
        isBursting = true;
        burstStartTime = performance.now() * 0.001;
        bgBurst = 1.0;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = geometry.attributes.position.array;
      const time = performance.now() * 0.001;

      // 爆发效果
      let burstFactor = 1.0;
      if (isBursting) {
        const elapsed = time - burstStartTime;
        if (elapsed < burstDuration) {
          burstFactor = 1.0 + 2.5 * Math.max(0, 1 - elapsed / burstDuration);
        } else {
          isBursting = false;
        }
      }

      for (let i = 0; i < particleCount; i++) {
        let idx = i * 3;
        let x = positions[idx];
        let y = positions[idx + 1];
        let z = positions[idx + 2];
        let dist = Math.sqrt(x * x + y * y + z * z);
        
        // 修改：根据粒子状态决定运动方式
        if (particleStates[i].mode === 'falling') {
          // 下落粒子：向下移动
          let fallSpeed = 1.5 * burstFactor;
          positions[idx + 1] -= fallSpeed;
          
          // 如果粒子落到底部，重新在中心生成并改为正常模式
          if (y < -120) {
            let r = 1 + Math.random() * 5; // 在中心小范围内生成
            let theta = Math.random() * 2 * Math.PI;
            let phi = Math.acos(2 * Math.random() - 1);
            positions[idx] = r * Math.sin(phi) * Math.cos(theta);
            positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[idx + 2] = r * Math.cos(phi);
            // 重新生成的粒子恢复正常模式
            particleStates[i].mode = 'normal';
            particleStates[i].createdAt = time;
          }
        } else {
          // 正常粒子：向外扩散
          let speed = (0.06 + dist * 0.004) * burstFactor;
          let dir = new THREE.Vector3(x, y, z).normalize();
          positions[idx] += dir.x * speed;
          positions[idx + 1] += dir.y * speed;
          positions[idx + 2] += dir.z * speed;
          
          // 如果粒子移动太远，重新在中心生成
          if (dist > 600) {
            let r = 1 + Math.random() * 5; // 在中心小范围内生成
            let theta = Math.random() * 2 * Math.PI;
            let phi = Math.acos(2 * Math.random() - 1);
            positions[idx] = r * Math.sin(phi) * Math.cos(theta);
            positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[idx + 2] = r * Math.cos(phi);
            particleStates[i].createdAt = time;
          }
        }
      }

      geometry.attributes.position.needsUpdate = true;
      particleSystem.rotation.y += 0.0002;
      updateBackground();
      renderer.render(scene, camera);
    }

    function lerpColor(c1, c2, t) {
      return [
        Math.round(c1[0] * (1 - t) + c2[0] * t),
        Math.round(c1[1] * (1 - t) + c2[1] * t),
        Math.round(c1[2] * (1 - t) + c2[2] * t)
      ];
    }

    function updateBackground() {
      bgPhase += 0.01;

      // 逐渐回落 - 加快背景变化速度
      if (bgBurst > 0) {
        bgBurst -= 0.008; // 加快爆发恢复速度
        if (bgBurst < 0) bgBurst = 0;
      }
      if (bgSquat > 0) {
        bgSquat -= 0.015; // 比原来快5倍
        if (bgSquat < 0) bgSquat = 0;
      }

      let mixBurst = bgBurst;
      let mixSquat = bgSquat * (1 - mixBurst);

      // 计算渐变位置和环位置
      const centerY = 50 + Math.cos(bgPhase * 0.5) * 5;
      const centerX = 50 + Math.sin(bgPhase * 0.7) * 5;

      // 预设主色
      const normalColors = {
        center: [160, 210, 255],
        ring1: [160, 210, 255], 
        ring2: [255, 179, 179],
        ring3: [255, 247, 176]
      };

      // 空格爆发：蓝紫色，更有冲击力
      const burstColor = [80, 60, 180];

      let gradientString = '';

      if (mixSquat > 0) {
        // 下沉模式：使用浅蓝色
        const lightSinkBlue = [180, 220, 255];    // 很浅的蓝色
        const sinkBlue = [150, 200, 250];         // 浅蓝色
        const sinkPink = [240, 150, 150];         // 稍微深一点的粉色
        const sinkYellow = [240, 220, 140];       // 稍微深一点的黄色
        
        // 蓝色区域的边界
        let blueTop = 50 - (5 * mixSquat);
        let blueBottom = 50 + (50 * (1 - mixSquat));
        
        // 创建渐变 - 使用更平滑的过渡
        gradientString = `linear-gradient(to bottom,
          rgb(${lerpColor(normalColors.center, lightSinkBlue, mixSquat * 0.3).join(',')}) 0%,
          rgb(${lerpColor(normalColors.center, lightSinkBlue, mixSquat * 0.5).join(',')}) ${Math.max(0, blueTop - 2)}%,
          rgb(${lerpColor(normalColors.center, sinkBlue, mixSquat * 0.8).join(',')}) ${blueTop}%,
          rgb(${lerpColor(sinkBlue, lightSinkBlue, mixSquat * 0.6).join(',')}) ${(blueTop + blueBottom) / 2}%,
          rgb(${lerpColor(normalColors.ring2, sinkPink, mixSquat * 0.4).join(',')}) ${blueBottom}%,
          rgb(${lerpColor(normalColors.ring3, sinkYellow, mixSquat * 0.3).join(',')}) ${Math.min(100, blueBottom + 5)}%
        )`;
      } else {
        // 正常模式：使用原有的径向渐变
        let center = normalColors.center;
        let ring1 = normalColors.ring1;
        let ring2 = normalColors.ring2;
        let ring3 = normalColors.ring3;
        
        // 爆发效果覆盖
        if (mixBurst > 0) {
          center = lerpColor(center, burstColor, mixBurst);
          ring1 = lerpColor(ring1, burstColor, mixBurst * 0.7);
          ring2 = lerpColor(ring2, burstColor, mixBurst * 0.4);
          ring3 = lerpColor(ring3, burstColor, mixBurst * 0.18);
        }
        
        const ring1Pos = 15;
        const ring2Pos = 50;
        const ring3Pos = 100;
        
        gradientString = `radial-gradient(circle at ${centerX}% ${centerY}%, 
          rgb(${center.join(',')}) 0%,
          rgb(${ring1.join(',')}) ${ring1Pos}%,
          rgb(${ring2.join(',')}) ${ring2Pos}%,
          rgb(${ring3.join(',')}) ${ring3Pos}%
        )`;
      }

      document.body.style.background = gradientString;
    }
  </script>
</body>
</html>