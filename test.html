<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Liquid Cloud Particle Flow</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle, #a0caff 0%, #ffb3b3 50%, #fff7b0 100%);
    }

    #bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
</head>

<body>
  <div id="bg"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, particleSystem;
    const particleCount = 8000;
    let geometry, material;
    let bgPhase = 0;
    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 180;

      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        let r = Math.random() * 80;
        let theta = Math.random() * 2 * Math.PI;
        let phi = Math.acos(2 * Math.random() - 1);

        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        sizes[i] = 2.0 + Math.random() * 2.0;

        // 蓝色粒子
        colors[i * 3] = 0.3 + Math.random() * 0.1;
        colors[i * 3 + 1] = 0.5 + Math.random() * 0.1;
        colors[i * 3 + 2] = 1.0;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));

      const vertexShader = `
        attribute float size;
        attribute vec3 aColor;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          vColor = aColor;
          float dist = length(position);
          vAlpha = 1.0 - smoothstep(0.0, 80.0, dist);
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          float d = distance(gl_PointCoord, vec2(0.5));
          float alpha = 1.0 - smoothstep(0.0, 0.5, d);
          gl_FragColor = vec4(vColor, alpha * vAlpha);
        }
      `;

      material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });

      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setClearColor(0x000000, 0); // 透明背景
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = geometry.attributes.position.array;
      const time = performance.now() * 0.001;

      for (let i = 0; i < particleCount; i++) {
        let idx = i * 3;

        // 获取原始位置
        let x = positions[idx];
        let y = positions[idx + 1];
        let z = positions[idx + 2];

        // 向外扩散速度与距离有关
        let dist = Math.sqrt(x * x + y * y + z * z);
        let speed = 0.03 + dist * 0.002;  // 中心快，外围慢

        // 单位方向向量
        let dir = new THREE.Vector3(x, y, z).normalize();

        // 更新位置
        positions[idx] += dir.x * speed;
        positions[idx + 1] += dir.y * speed;
        positions[idx + 2] += dir.z * speed;

        // 如果粒子太远，重新初始化为中心附近
        if (dist > 80) {
          let r = 1 + Math.random() * 2;  // 初始半径更靠近中心
          let theta = Math.random() * 2 * Math.PI;
          let phi = Math.acos(2 * Math.random() - 1);

          let newX = r * Math.sin(phi) * Math.cos(theta);
          let newY = r * Math.sin(phi) * Math.sin(theta);
          let newZ = r * Math.cos(phi);

          positions[idx] = newX;
          positions[idx + 1] = newY;
          positions[idx + 2] = newZ;
        }
      }

      geometry.attributes.position.needsUpdate = true;
      particleSystem.rotation.y += 0.0002; // 可以保留轻微旋转，增加动感
      updateBackground();
      renderer.render(scene, camera);
    }



    function updateBackground() {
      bgPhase += 0.01;

      const centerX = 50 + Math.sin(bgPhase * 0.7) * 5;  // 中心只轻微偏移
      const centerY = 50 + Math.cos(bgPhase * 0.5) * 5;

      // 中心颜色轻微波动
      const r = Math.floor(160 + 10 * Math.sin(bgPhase * 0.5));
      const g = Math.floor(210 + 10 * Math.cos(bgPhase * 0.8));
      const b = 255;

      const innerColor = `rgb(${r}, ${g}, ${b})`;

      // 只让中心颜色变，其它颜色固定
      document.body.style.background = `
        radial-gradient(circle at ${centerX}% ${centerY}%,
          ${innerColor} 0%,
          #a0caff 10%,
          #ffb3b3 50%,
          #fff7b0 100%)
      `;
    }


  </script>
</body>

</html>