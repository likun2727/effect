<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Liquid Cloud Particle Flow</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle, #a0caff 0%, #ffb3b3 50%, #fff7b0 100%);
    }

    #bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
</head>

<body>
  <div id="bg"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, particleSystem;
    const particleCount = 8000;
    let geometry, material;
    let bgPhase = 0;
    let particleSquat = 0;
    let bgSquat = 0;
    let bgArm = 0;
    let isBursting = false;
    let isArming = false;
    let bgBurst = 0;
    let innerMix = bgBurst;
    let midMix = bgBurst * 0.5;
    let outMix = bgBurst * 0.2;
    let burstStartTime = 0;
    let armStartTime = 0;
    const burstDuration = 1.0;
    const armDuration = 1.8;
    
    // 修改：记录每个粒子的运动模式和创建时间
    let particleStates = new Array(particleCount).fill().map(() => ({
      mode: 'normal', // 'normal', 'falling', 'arming', 'rising', 'arm_bursting'
      createdAt: 0,
      armTarget: { x: 0, y: 0, z: 0 }, // 聚集目标点
      spiralPhase: Math.random() * Math.PI * 2 // 螺旋相位
    }));
    
    init();
    animate();

    // 监听键盘
    window.addEventListener('keydown', function (e) {
      // 空格键
      if (e.code === 'Space' && !isBursting) {
        triggerBurst()
      }
      if (e.key === 's' || e.key === 'S') {
        bgSquat = 1.0;
        particleSquat = 1.0;
        // 修改：将当前所有粒子标记为下落模式，但不改变它们的位置
        const currentTime = performance.now() * 0.001;
        for (let i = 0; i < particleCount; i++) {
          particleStates[i].mode = 'falling';
          particleStates[i].createdAt = currentTime;
        }
      }
      if (e.key === 'b' || e.key === 'B') {
        if (!isArming) {
          triggerArm();
        }
      }
    });

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 180;

      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        // 修改：所有粒子都从中心球形区域生成
        let r = Math.random() * 80;
        let theta = Math.random() * 2 * Math.PI;
        let phi = Math.acos(2 * Math.random() - 1);
        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        sizes[i] = 2.0 + Math.random() * 2.0;

        // 蓝色粒子
        colors[i * 3] = 0.3 + Math.random() * 0.1;
        colors[i * 3 + 1] = 0.5 + Math.random() * 0.1;
        colors[i * 3 + 2] = 1.0;
        
        // 初始化粒子状态
        particleStates[i] = {
          mode: 'normal',
          createdAt: 0
        };
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));

      const vertexShader = `
        attribute float size;
        attribute vec3 aColor;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          vColor = aColor;
          float dist = length(position);
          vAlpha = 1.0 - smoothstep(0.0, 520.0, dist);
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const fragmentShader = `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          float d = distance(gl_PointCoord, vec2(0.5));
          float alpha = 1.0 - smoothstep(0.0, 0.5, d);
          gl_FragColor = vec4(vColor, alpha * vAlpha);
        }
      `;

      material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });

      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function triggerBurst() {
      if (!isBursting) {
        isBursting = true;
        burstStartTime = performance.now() * 0.001;
        bgBurst = 1.0;
      }
    }

    function triggerArm() {
      if (!isArming) {
        isArming = true;
        armStartTime = performance.now() * 0.001;
        bgArm = 1.0;
        
        // 设置聚集目标点（模拟肘部位置，在右下方）
        const elbowX = 40;
        const elbowY = -20;
        const elbowZ = 0;
        
        const currentTime = performance.now() * 0.001;
        for (let i = 0; i < particleCount; i++) {
          particleStates[i].mode = 'arming';
          particleStates[i].createdAt = currentTime;
          particleStates[i].armTarget = { x: elbowX, y: elbowY, z: elbowZ };
          particleStates[i].spiralPhase = Math.random() * Math.PI * 2;
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const positions = geometry.attributes.position.array;
      const time = performance.now() * 0.001;

      // 爆发效果
      let burstFactor = 1.0;
      if (isBursting) {
        const elapsed = time - burstStartTime;
        if (elapsed < burstDuration) {
          burstFactor = 1.0 + 2.5 * Math.max(0, 1 - elapsed / burstDuration);
        } else {
          isBursting = false;
        }
      }

      // 抬臂效果
      let armPhase = 0;
      if (isArming) {
        const elapsed = time - armStartTime;
        if (elapsed < armDuration) {
          armPhase = elapsed / armDuration;
        } else {
          isArming = false;
          // 抬臂结束后，粒子回到正常模式
          for (let i = 0; i < particleCount; i++) {
            if (particleStates[i].mode.includes('arm')) {
              particleStates[i].mode = 'normal';
            }
          }
        }
      }

      for (let i = 0; i < particleCount; i++) {
        let idx = i * 3;
        let x = positions[idx];
        let y = positions[idx + 1];
        let z = positions[idx + 2];
        let dist = Math.sqrt(x * x + y * y + z * z);
        
        // 修改：根据粒子状态决定运动方式
        if (particleStates[i].mode === 'falling') {
          // 下落粒子：向下移动
          let fallSpeed = 1.5 * burstFactor;
          positions[idx + 1] -= fallSpeed;
          
          // 如果粒子落到底部，重新在中心生成并改为正常模式
          if (y < -120) {
            let r = 1 + Math.random() * 5; // 在中心小范围内生成
            let theta = Math.random() * 2 * Math.PI;
            let phi = Math.acos(2 * Math.random() - 1);
            positions[idx] = r * Math.sin(phi) * Math.cos(theta);
            positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[idx + 2] = r * Math.cos(phi);
            // 重新生成的粒子恢复正常模式
            particleStates[i].mode = 'normal';
            particleStates[i].createdAt = time;
          }
        } else if (particleStates[i].mode === 'arming') {
          // 抬臂效果
          if (armPhase < 0.3) {
            // 阶段1：聚集到肘部位置 (0-0.3)
            let progress = armPhase / 0.3;
            let target = particleStates[i].armTarget;
            let lerpSpeed = 0.08 * progress;
            
            positions[idx] += (target.x - x) * lerpSpeed;
            positions[idx + 1] += (target.y - y) * lerpSpeed;
            positions[idx + 2] += (target.z - z) * lerpSpeed;
          } else if (armPhase < 0.8) {
            // 阶段2：螺旋上升 (0.3-0.8)
            let progress = (armPhase - 0.3) / 0.5;
            let spiralRadius = 15 * (1 - progress * 0.5);
            let spiralSpeed = 2.0;
            
            particleStates[i].spiralPhase += 0.15;
            let spiralX = Math.cos(particleStates[i].spiralPhase) * spiralRadius;
            let spiralZ = Math.sin(particleStates[i].spiralPhase) * spiralRadius;
            
            positions[idx] = particleStates[i].armTarget.x + spiralX;
            positions[idx + 1] += spiralSpeed;
            positions[idx + 2] = particleStates[i].armTarget.z + spiralZ;
          } else {
            // 阶段3：顶点爆发 (0.8-1.0)
            let progress = (armPhase - 0.8) / 0.2;
            let explosionSpeed = 3.0 * progress;
            let dir = new THREE.Vector3(x - particleStates[i].armTarget.x, y - particleStates[i].armTarget.y, z - particleStates[i].armTarget.z).normalize();
            
            positions[idx] += dir.x * explosionSpeed;
            positions[idx + 1] += dir.y * explosionSpeed + 1.0; // 向上偏移
            positions[idx + 2] += dir.z * explosionSpeed;
          }
        } else {
          // 正常粒子：向外扩散
          let speed = (0.06 + dist * 0.004) * burstFactor;
          let dir = new THREE.Vector3(x, y, z).normalize();
          positions[idx] += dir.x * speed;
          positions[idx + 1] += dir.y * speed;
          positions[idx + 2] += dir.z * speed;
          
          // 如果粒子移动太远，重新在中心生成
          if (dist > 600) {
            let r = 1 + Math.random() * 5; // 在中心小范围内生成
            let theta = Math.random() * 2 * Math.PI;
            let phi = Math.acos(2 * Math.random() - 1);
            positions[idx] = r * Math.sin(phi) * Math.cos(theta);
            positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[idx + 2] = r * Math.cos(phi);
            particleStates[i].createdAt = time;
          }
        }
      }

      geometry.attributes.position.needsUpdate = true;
      particleSystem.rotation.y += 0.0002;
      updateBackground();
      renderer.render(scene, camera);
    }

    function lerpColor(c1, c2, t) {
      return [
        Math.round(c1[0] * (1 - t) + c2[0] * t),
        Math.round(c1[1] * (1 - t) + c2[1] * t),
        Math.round(c1[2] * (1 - t) + c2[2] * t)
      ];
    }

    function updateBackground() {
      bgPhase += 0.01;

      // 逐渐回落 - 加快背景变化速度
      if (bgBurst > 0) {
        bgBurst -= 0.008; // 加快爆发恢复速度
        if (bgBurst < 0) bgBurst = 0;
      }
      if (bgSquat > 0) {
        bgSquat -= 0.015; // 比原来快5倍
        if (bgSquat < 0) bgSquat = 0;
      }
      if (bgArm > 0) {
        bgArm -= 0.006; // 抬臂效果恢复速度
        if (bgArm < 0) bgArm = 0;
      }

      let mixBurst = bgBurst;
      let mixSquat = bgSquat * (1 - mixBurst);
      let mixArm = bgArm * (1 - mixBurst) * (1 - mixSquat);

      // 计算渐变位置和环位置
      const centerY = 50 + Math.cos(bgPhase * 0.5) * 5;
      const centerX = 50 + Math.sin(bgPhase * 0.7) * 5;

      // 预设主色
      const normalColors = {
        center: [160, 210, 255],
        ring1: [160, 210, 255], 
        ring2: [255, 179, 179],
        ring3: [255, 247, 176]
      };

      // 空格爆发：蓝紫色，更有冲击力
      const burstColor = [80, 60, 180];

      let gradientString = '';

      if (mixArm > 0) {
        // 抬臂模式：从深蓝→紫色→金黄色的渐变上升
        const armPhase = isArming ? (performance.now() * 0.001 - armStartTime) / armDuration : 0;
        
        let armColor1, armColor2, armColor3;
        if (armPhase < 0.3) {
          // 蓄力阶段：深蓝→紫色
          armColor1 = [40, 60, 120];   // 深蓝
          armColor2 = [80, 40, 140];   // 深紫
          armColor3 = [60, 80, 160];   // 蓝紫
        } else if (armPhase < 0.8) {
          // 上升阶段：紫色→金紫色
          armColor1 = [80, 40, 140];   // 深紫
          armColor2 = [140, 80, 160];  // 亮紫
          armColor3 = [180, 120, 60];  // 金紫
        } else {
          // 爆发阶段：金黄色
          armColor1 = [200, 160, 40];  // 金黄
          armColor2 = [240, 200, 80];  // 亮金
          armColor3 = [255, 220, 100]; // 最亮金
        }
        
        // 从下往上的能量上升渐变
        const energyPosition = Math.min(90, 20 + armPhase * 70);
        
        gradientString = `linear-gradient(to top,
          rgb(${lerpColor(normalColors.ring3, armColor1, mixArm * 0.8).join(',')}) 0%,
          rgb(${lerpColor(normalColors.ring2, armColor2, mixArm * 0.9).join(',')}) ${energyPosition - 20}%,
          rgb(${lerpColor(normalColors.center, armColor3, mixArm).join(',')}) ${energyPosition}%,
          rgb(${lerpColor(normalColors.center, armColor3, mixArm * 0.7).join(',')}) ${Math.min(100, energyPosition + 10)}%
        )`;
      } else if (mixSquat > 0) {
        // 下沉模式：使用浅蓝色
        const lightSinkBlue = [180, 220, 255];    // 很浅的蓝色
        const sinkBlue = [150, 200, 250];         // 浅蓝色
        const sinkPink = [240, 150, 150];         // 稍微深一点的粉色
        const sinkYellow = [240, 220, 140];       // 稍微深一点的黄色
        
        // 蓝色区域的边界
        let blueTop = 50 - (5 * mixSquat);
        let blueBottom = 50 + (50 * (1 - mixSquat));
        
        // 创建渐变 - 使用更平滑的过渡
        gradientString = `linear-gradient(to bottom,
          rgb(${lerpColor(normalColors.center, lightSinkBlue, mixSquat * 0.3).join(',')}) 0%,
          rgb(${lerpColor(normalColors.center, lightSinkBlue, mixSquat * 0.5).join(',')}) ${Math.max(0, blueTop - 2)}%,
          rgb(${lerpColor(normalColors.center, sinkBlue, mixSquat * 0.8).join(',')}) ${blueTop}%,
          rgb(${lerpColor(sinkBlue, lightSinkBlue, mixSquat * 0.6).join(',')}) ${(blueTop + blueBottom) / 2}%,
          rgb(${lerpColor(normalColors.ring2, sinkPink, mixSquat * 0.4).join(',')}) ${blueBottom}%,
          rgb(${lerpColor(normalColors.ring3, sinkYellow, mixSquat * 0.3).join(',')}) ${Math.min(100, blueBottom + 5)}%
        )`;
      } else {
        // 正常模式：使用原有的径向渐变
        let center = normalColors.center;
        let ring1 = normalColors.ring1;
        let ring2 = normalColors.ring2;
        let ring3 = normalColors.ring3;
        
        // 爆发效果覆盖
        if (mixBurst > 0) {
          center = lerpColor(center, burstColor, mixBurst);
          ring1 = lerpColor(ring1, burstColor, mixBurst * 0.7);
          ring2 = lerpColor(ring2, burstColor, mixBurst * 0.4);
          ring3 = lerpColor(ring3, burstColor, mixBurst * 0.18);
        }
        
        const ring1Pos = 15;
        const ring2Pos = 50;
        const ring3Pos = 100;
        
        gradientString = `radial-gradient(circle at ${centerX}% ${centerY}%, 
          rgb(${center.join(',')}) 0%,
          rgb(${ring1.join(',')}) ${ring1Pos}%,
          rgb(${ring2.join(',')}) ${ring2Pos}%,
          rgb(${ring3.join(',')}) ${ring3Pos}%
        )`;
      }

      document.body.style.background = gradientString;
    }
  </script>
</body>
</html>